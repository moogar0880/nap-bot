// Code generated by "go run generate_getters.go"; DO NOT EDIT.
package venom

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestGlobalGetBool(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect bool
	}{
		{
			tc:     "should get bool",
			key:    "test.bool",
			value:  bool(true),
			expect: true,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.bool",
			value:  nil,
			expect: false,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.bool",
			value:  120,
			expect: false,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetBool(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetBool(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect bool
	}{
		{
			tc:     "should get bool",
			key:    "test.bool",
			value:  bool(true),
			expect: true,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.bool",
			value:  nil,
			expect: false,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.bool",
			value:  120,
			expect: false,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetBool(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetFloat32(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect float32
	}{
		{
			tc:     "should get float32",
			key:    "test.float32",
			value:  float32(8675.309),
			expect: 8675.309,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.float32",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.float32",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetFloat32(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetFloat32(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect float32
	}{
		{
			tc:     "should get float32",
			key:    "test.float32",
			value:  float32(8675.309),
			expect: 8675.309,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.float32",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.float32",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetFloat32(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetFloat64(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect float64
	}{
		{
			tc:     "should get float64",
			key:    "test.float64",
			value:  float64(8675.309),
			expect: 8675.309,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.float64",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.float64",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetFloat64(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetFloat64(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect float64
	}{
		{
			tc:     "should get float64",
			key:    "test.float64",
			value:  float64(8675.309),
			expect: 8675.309,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.float64",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.float64",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetFloat64(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetInt(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect int
	}{
		{
			tc:     "should get int",
			key:    "test.int",
			value:  int(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.int",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.int",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetInt(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetInt(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect int
	}{
		{
			tc:     "should get int",
			key:    "test.int",
			value:  int(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.int",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.int",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetInt(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetInt8(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect int8
	}{
		{
			tc:     "should get int8",
			key:    "test.int8",
			value:  int8(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.int8",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.int8",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetInt8(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetInt8(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect int8
	}{
		{
			tc:     "should get int8",
			key:    "test.int8",
			value:  int8(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.int8",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.int8",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetInt8(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetInt16(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect int16
	}{
		{
			tc:     "should get int16",
			key:    "test.int16",
			value:  int16(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.int16",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.int16",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetInt16(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetInt16(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect int16
	}{
		{
			tc:     "should get int16",
			key:    "test.int16",
			value:  int16(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.int16",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.int16",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetInt16(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetInt32(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect int32
	}{
		{
			tc:     "should get int32",
			key:    "test.int32",
			value:  int32(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.int32",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.int32",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetInt32(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetInt32(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect int32
	}{
		{
			tc:     "should get int32",
			key:    "test.int32",
			value:  int32(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.int32",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.int32",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetInt32(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetInt64(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect int64
	}{
		{
			tc:     "should get int64",
			key:    "test.int64",
			value:  int64(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.int64",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.int64",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetInt64(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetInt64(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect int64
	}{
		{
			tc:     "should get int64",
			key:    "test.int64",
			value:  int64(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.int64",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.int64",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetInt64(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetString(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect string
	}{
		{
			tc:     "should get string",
			key:    "test.string",
			value:  string("foobar"),
			expect: "foobar",
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.string",
			value:  nil,
			expect: "",
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.string",
			value:  true,
			expect: "",
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetString(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetString(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect string
	}{
		{
			tc:     "should get string",
			key:    "test.string",
			value:  string("foobar"),
			expect: "foobar",
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.string",
			value:  nil,
			expect: "",
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.string",
			value:  true,
			expect: "",
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetString(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetUint(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect uint
	}{
		{
			tc:     "should get uint",
			key:    "test.uint",
			value:  uint(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.uint",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.uint",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetUint(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetUint(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect uint
	}{
		{
			tc:     "should get uint",
			key:    "test.uint",
			value:  uint(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.uint",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.uint",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetUint(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetUint8(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect uint8
	}{
		{
			tc:     "should get uint8",
			key:    "test.uint8",
			value:  uint8(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.uint8",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.uint8",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetUint8(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetUint8(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect uint8
	}{
		{
			tc:     "should get uint8",
			key:    "test.uint8",
			value:  uint8(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.uint8",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.uint8",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetUint8(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetUint16(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect uint16
	}{
		{
			tc:     "should get uint16",
			key:    "test.uint16",
			value:  uint16(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.uint16",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.uint16",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetUint16(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetUint16(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect uint16
	}{
		{
			tc:     "should get uint16",
			key:    "test.uint16",
			value:  uint16(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.uint16",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.uint16",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetUint16(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetUint32(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect uint32
	}{
		{
			tc:     "should get uint32",
			key:    "test.uint32",
			value:  uint32(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.uint32",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.uint32",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetUint32(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetUint32(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect uint32
	}{
		{
			tc:     "should get uint32",
			key:    "test.uint32",
			value:  uint32(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.uint32",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.uint32",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetUint32(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGlobalGetUint64(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect uint64
	}{
		{
			tc:     "should get uint64",
			key:    "test.uint64",
			value:  uint64(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.uint64",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.uint64",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := GetUint64(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGetUint64(t *testing.T) {
	testIO := []struct {
		tc     string
		key    string
		value  interface{}
		expect uint64
	}{
		{
			tc:     "should get uint64",
			key:    "test.uint64",
			value:  uint64(120),
			expect: 120,
		},
		{
			tc:     "should fail if key doesn't exist",
			key:    "test.uint64",
			value:  nil,
			expect: 0,
		},
		{
			tc:     "should fail if types are incompatible",
			key:    "test.uint64",
			value:  "foobar",
			expect: 0,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T) {
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.GetUint64(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

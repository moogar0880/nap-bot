//+build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"reflect"
	"strings"
)

const packageHdr = `
// Code generated by "go run generate_getters.go"; DO NOT EDIT.
package venom
`

const testHdr = `
// Code generated by "go run generate_getters.go"; DO NOT EDIT.
package venom

import (
	"testing"

	"github.com/stretchr/testify/assert"
)
`

var (
	types = []reflect.Kind{
		reflect.Bool,
		reflect.Float32, reflect.Float64,
		reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.String,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32,
		reflect.Uint64,
	}

	kindToType = map[reflect.Kind]reflect.Type{
		reflect.Bool:    reflect.TypeOf(true),
		reflect.Float32: reflect.TypeOf(float32(0.0)),
		reflect.Float64: reflect.TypeOf(float64(0.0)),
		reflect.Int:     reflect.TypeOf(int(0)),
		reflect.Int16:   reflect.TypeOf(int16(0)),
		reflect.Int32:   reflect.TypeOf(int32(0)),
		reflect.Int64:   reflect.TypeOf(int64(0)),
		reflect.Int8:    reflect.TypeOf(int8(0)),
		reflect.String:  reflect.TypeOf(""),
		reflect.Uint:    reflect.TypeOf(uint(0)),
		reflect.Uint16:  reflect.TypeOf(uint16(0)),
		reflect.Uint32:  reflect.TypeOf(uint32(0)),
		reflect.Uint64:  reflect.TypeOf(uint64(0)),
		reflect.Uint8:   reflect.TypeOf(uint8(0)),
	}
)

func validValueFor(k reflect.Kind) string {
	switch k {
	case reflect.String:
		return `"foobar"`
	case reflect.Bool:
		return "true"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return "120"
	default: // the rest are all float types
		return "8675.309"
	}
}

func invalidValueFor(k reflect.Kind) string {
	switch k {
	case reflect.String:
		return "true"
	case reflect.Bool:
		return "120"
	default: // the rest are all numerical types
		return `"foobar"`
	}
}

func zeroValue(k reflect.Kind) interface{} {
	return reflect.Zero(kindToType[k]).Interface()
}

func kindTitle(k reflect.Kind) string {
	return strings.Replace(
		k.String(),
		string(k.String()[0]),
		strings.ToUpper(string(k.String()[0])),
		-1,
	)
}

func writeGetter(k reflect.Kind) string {
	zeroValFmt := "%v"
	if k == reflect.String {
		zeroValFmt = "%q"
	}
	return fmt.Sprintf(`
// Get%s attempts to cast the returned config value from the global
// Venom instance
func Get%s(key string) %s {
	return v.Get%s(key)
}

// Get%s attempts to cast the returned config value from the current
// Venom instance. 
//
// If the key does not exist, or if the type contained in Venom can
// not be cast to the requested type, then the zero value of `+zeroValFmt+`
// will be returned.
func (v *Venom) Get%s(key string) %s {
	val, ok := v.Find(key)
	if !ok {
		return `+zeroValFmt+`
	}

	if value, ok := val.(%s); !ok {
		return `+zeroValFmt+`
	} else {
		return value
	}
}

`,
		kindTitle(k),
		kindTitle(k),
		k,
		kindTitle(k),
		kindTitle(k),
		zeroValue(k),
		kindTitle(k),
		k,
		zeroValue(k),
		k,
		zeroValue(k))
}

func writeGetterTest(k reflect.Kind) string {
	zeroValFmt := "%v"
	if k == reflect.String {
		zeroValFmt = "%q"
	}
	return fmt.Sprintf(`
func TestGlobalGet%s(t * testing.T) {
	testIO := []struct{
		tc    string
		key   string
		value interface{}
		expect %s
	}{
		{
			tc: "should get %s",
			key: "test.%s",
			value: %s(%s),
			expect: %s,
		},
		{
			tc: "should fail if key doesn't exist",
			key: "test.%s",
			value: nil,
			expect: `+zeroValFmt+`,
		},
		{
			tc: "should fail if types are incompatible",
			key: "test.%s",
			value: %s,
			expect: `+zeroValFmt+`,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T){
			defer v.Clear()

			if test.value != nil {
				SetDefault(test.key, test.value)
			}

			actual := Get%s(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}

func TestGet%s(t * testing.T) {
	testIO := []struct{
		tc    string
		key   string
		value interface{}
		expect %s
	}{
		{
			tc: "should get %s",
			key: "test.%s",
			value: %s(%s),
			expect: %s,
		},
		{
			tc: "should fail if key doesn't exist",
			key: "test.%s",
			value: nil,
			expect: `+zeroValFmt+`,
		},
		{
			tc: "should fail if types are incompatible",
			key: "test.%s",
			value: %s,
			expect: `+zeroValFmt+`,
		},
	}

	for _, test := range testIO {
		t.Run(test.tc, func(t *testing.T){
			ven := New()

			if test.value != nil {
				ven.SetDefault(test.key, test.value)
			}

			actual := ven.Get%s(test.key)
			assert.Equal(t, test.expect, actual)
		})
	}
}
`, // global test case
		kindTitle(k),
		k,
		k,
		k,
		k,
		validValueFor(k),
		validValueFor(k),
		k,
		zeroValue(k),
		k,
		invalidValueFor(k),
		zeroValue(k),
		kindTitle(k),

		// specific instance test case
		kindTitle(k),
		k,
		k,
		k,
		k,
		validValueFor(k),
		validValueFor(k),
		k,
		zeroValue(k),
		k,
		invalidValueFor(k),
		zeroValue(k),
		kindTitle(k),
	)
}

func formatAndWrite(buff *bytes.Buffer, fileName string) error {
	// gofmt
	res, err := format.Source(buff.Bytes())
	if err != nil {
		fmt.Println(buff.String())
		panic(err.Error())
	}

	// write result
	f, err := os.Create(fileName)
	if err != nil {
		panic(err.Error())
	}
	defer f.Close()
	f.Write(res)
	return nil
}

func writeGetters(buff *bytes.Buffer) error {
	buff.WriteString(packageHdr)

	for _, typ := range types {
		fmt.Fprint(buff, writeGetter(typ))
	}

	return formatAndWrite(buff, "getters.go")
}

func writeGetterTests(buff *bytes.Buffer) error {
	buff.WriteString(testHdr)

	for _, typ := range types {
		fmt.Fprint(buff, writeGetterTest(typ))
	}

	return formatAndWrite(buff, "getters_test.go")
}

func main() {
	gettersBuff := new(bytes.Buffer)
	writeGetters(gettersBuff)

	testsBuff := new(bytes.Buffer)
	writeGetterTests(testsBuff)
}
